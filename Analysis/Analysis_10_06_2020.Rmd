---
title: "Analysis NoiseStrike 2020"
author: 'Clara Kuper'
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*. 

```{r}
library(ggplot2)


## Define a blank theme for plots
fontsize = 9

blanktheme <-  theme_bw() + theme(legend.position="Bottom") + 
	
	# Set information about ticks
	theme(axis.ticks=element_line(size=0.2358491)) +
	theme(axis.ticks.length=unit(0.05,"cm")) +

	# Remove all pre-defined lines
	theme(panel.grid.major=element_blank()) +
	theme(panel.grid.minor=element_blank()) +
	theme(panel.background=element_blank()) +
	#theme(panel.border=element_blank()) +
	theme(plot.background=element_blank()) +

	# Determine style of box
	theme(axis.line = element_line(color= "black",size=0.2358491)) +	#results in 0.5pt
	
	# Determine font size of axes
	theme(text = element_text(size=fontsize)) +
	theme(axis.title.y=element_text(vjust=0.3,size=fontsize)) +
	theme(axis.title.x=element_text(vjust=0.3,size=fontsize)) +	
	theme(axis.text.x = element_text(size= fontsize)) +
	theme(axis.text.y = element_text(size= fontsize)) +
	theme(strip.text.x = element_text(size= fontsize)) +
	theme(strip.text.y = element_text(size= fontsize))



```

Step 1: Load the data from all participants

```{r}
setwd('..')
basewd <- getwd()
datPath <- paste(basewd, '/Data/', sep = "")

datFiles <- list.files(datPath, pattern = ".csv")
d <- NULL


for (file in datFiles){
  
  subject_name <- substr(file,1,2)
  
  session_nr   <- substr(file,3,4)
  filedir      <- paste(datPath,file, sep = "")
  data         <- read.csv(filedir)
  data$participant <- subject_name 
  data$session     <- session_nr
    
  distDir <- paste(datPath,'AddOn/yDist_',subject_name,session_nr,'.csv', sep = "")
  yDist   <- read.csv(distDir, header = FALSE)
    
  data$dirNorm <- yDist[,1]
  
  if (! is.null(d)) {
    names(data) <- names(d)
  }
  
  d <- rbind(d,data)
  
}

```

Step 2: Find hit/false alarm/correct rejection/miss responses

```{r}

d$resp_correct <- 0
d$resp_correct[which(d$goResp==d$hitGoal)] <- 1

for (participant in unique(d$participant)){
  p_correct <- mean(d$resp_correct[which(d$participant == participant)]) *100
  
  print(paste('Participant', participant, 'gave correct answers in', p_correct, 'percent of the trials'))
  
}

# add information about lower an upper bound hit
d$upper <- 0
d$upper[which(d$dirNorm > 0)] <- 1
d$upper[which(d$dirNorm == 0)] <- 2


```


Step 3: Compute the reaction time per response


```{r}
# Clean the reaction times

clean_idx = which(is.nan(d$rea_time)|d$rea_time < 0)
cleaned_d = d[-clean_idx,]

for (participant in unique(d$participant)){
  for (resp in unique(d$goResp)){
    for (goal in unique(d$hitGoal)){
      
     cond_data <- cleaned_d[which(cleaned_d$hitGoal == goal & cleaned_d$goResp == resp & cleaned_d$participant == participant),]
     
     print(paste('Participant', participant, 'reacted within', mean(cond_data$rea_time), 'in trials with goal', goal, 'and response', resp))
      
    }
  }
}  
```


Step 4: Write a function that computes % correct answers of an interval 
```{r}

integrate_over <- function(x_values, y_values, participants, step_n) {
   
   start <- min(y_values,na.rm = TRUE)
   stop <- max(y_values,na.rm = TRUE)
   step_size <- (stop-start)/step_n
   sequence <- seq(start, stop, step_size)
   
   out_mat <- matrix(ncol = 2, nrow = (length(sequence)-1)*length(unique(participants)))
   pat_mat <- matrix(ncol = 1, nrow = (length(sequence)-1)*length(unique(participants)))
   
   for (participant in unique(participants)){
     for (step in sequence){
       if (step == start){
         last <- step
         if (is.na(out_mat[1,1])){
          idx <- 1 
         }
       }
       else {
         val_idx <- which(y_values>=last & y_values < step & participants == participant)
         x_mean <- mean(x_values[val_idx], na.rm = TRUE)
         y_mean <- mean (last, step, na.rm = TRUE)
         
         last <- step
         
         out_mat[idx,1] <- as.numeric(y_mean)
         out_mat[idx,2] <- as.numeric(x_mean)
         pat_mat[idx,1] <- participant
         
         idx <- idx+1
       }
    }   
  }
  out_df <- as.data.frame(out_mat) 
  pat_df <- as.data.frame(pat_mat)
  
  out_df <- cbind(out_df, pat_df)
  return(out_df)
}

```

Step 5: Plot the reaction type as a function of how far the attacker landed in the center.
        Plot proportion correct answers as a fuction of where the attacker landed.
        Do the same with the reaction time. (Maybe only for trial with a response)
        
```{r}
# proportion correct responses as response to attacker - center goal



correct_resp_attacker_center <- integrate_over(cleaned_d$resp_correct, cleaned_d$dirNorm, cleaned_d$participant, 9)
colnames(correct_resp_attacker_center) <- c('attacker_pos', 'response', 'participant')


plot1 <- ggplot(correct_resp_attacker_center, aes(attacker_pos,response, group = participant))+
  geom_point(aes(color=participant))+
  geom_smooth(aes(color = participant), se = FALSE)+
  xlab('Final position of the attacker relative to goal center (in dva)')+
  ylab('proportion correct responses')+
  blanktheme

plot1


reaction_time_attacker_center <- integrate_over(cleaned_d$rea_time, abs(cleaned_d$dirNorm), cleaned_d$participant, 9)
colnames(reaction_time_attacker_center) <- c('attacker_pos', 'rea_time', 'participant')


plot2 <- ggplot(reaction_time_attacker_center, aes(attacker_pos,rea_time, group = participant))+
  geom_point(aes(color=participant))+
  xlab('Final position of the attacker relative to goal center in dva')+
  ylab('reaction times in s')+
  blanktheme

plot2


# correct responses as a function of the first stimulus

correct_responses_target_center <- integrate_over(cleaned_d$resp_correct,abs(cleaned_d$pos_vals_.1), cleaned_d$participant, 9)
colnames(correct_responses_target_center) <- c('target_pos', 'response', 'participant')


plot3 <- ggplot(correct_responses_target_center, aes(abs(target_pos),response, group = participant))+
  geom_point(aes(color = participant))+
  geom_smooth(aes(color = participant), se = FALSE)+
  xlab('Distance of the first target relative to goal center (in dva)')+
  ylab('proportion correct responses')+
  blanktheme

plot3


```

Step 6: Normalize the targets to the attacker end point

```{r}

d_attacker_norm <- cleaned_d
idx_first_target <- which(colnames(d_attacker_norm)=='pos_vals_.1')
idx_last_target <-  which(colnames(d_attacker_norm)=='pos_vals_60')


for (col in idx_first_target:idx_last_target){
  d_attacker_norm[,col] <- sqrt(((d_attacker_norm[,col] - d_attacker_norm$dirNorm) ^ 2))  
}


# plot go respones as a function of the first presented target

go_response_attacker_first_target <- integrate_over(d_attacker_norm$goResp,d_attacker_norm$pos_vals_.1, d_attacker_norm$participant, 9)
colnames(go_response_attacker_first_target) <- c('first_pos', 'go_responses', 'participant')


plot4 <- ggplot(go_response_attacker_first_target, aes(first_pos,go_responses, group = participant))+
  geom_point(aes(color = participant))+
  geom_smooth(aes(color = participant), se = FALSE)+
  xlab('Distance of the first target to target enpoint (in dva)')+
  ylab('Proportion go responses')+
  blanktheme

plot4

```

Step 8: Plot the mean presented target location (relative to the goal) at time t before movement onset.


```{r}
# only trials with go response
norm_to_mov_d <- cleaned_d

# in which column index is the first 
idx_first_target <- which(colnames(norm_to_mov_d)=='pos_vals_.1')
idx_move_on <- idx_first_target + norm_to_mov_d$posMovStart
idx_move_off <- idx_first_target + norm_to_mov_d$posMovEnd

presented_tars <- max(idx_move_on-idx_first_target)

rev_mat <- matrix(ncol = presented_tars+2, nrow = length(norm_to_mov_d[,1]))
rev_frame   <- as.data.frame(rev_mat)


for (r in 1:length(norm_to_mov_d[,1])){
  
  start_target <- idx_move_on[r]
  target_seq   <- norm_to_mov_d[r,start_target:idx_first_target]
  rev_frame[r,presented_tars+1] <- norm_to_mov_d$resp_correct[r]
  rev_frame[r,presented_tars+2] <- norm_to_mov_d$participant[r]
  rev_frame[r,1:length(target_seq)] <- target_seq
}



rev_hit   <- rev_frame[which(rev_frame[,presented_tars+1]==1 & cleaned_d$goResp==1),]
rev_false <- rev_frame[which(rev_frame[,presented_tars+1]==0 & cleaned_d$goResp==1),]




colN <- 8
dt <- -(1/120)*5

resp_rev_frame <- matrix(ncol = 4, nrow = (colN*length(unique(rev_frame$participant))))
resp_rev_frame <- as.data.frame(resp_rev_frame)

idx = 1

for (participant in unique(rev_frame$participant)){
  t <- 0
  for (frame in 1:colN){
    resp_rev_frame[idx,1] <- t
    resp_rev_frame[idx,2] <- mean(abs(rev_hit[which(rev_hit[,presented_tars+2]==participant),frame]), na.rm =  TRUE)
    resp_rev_frame[idx,3] <- mean(abs(rev_false[which(rev_false[,presented_tars+2]==participant),frame]), na.rm =  TRUE)
    resp_rev_frame[idx,4] <- participant
    t <- t+dt
    idx <- idx+1
  }  
}

colnames(resp_rev_frame) <- c('time', 'mean_target_hit', 'mean_target_false', 'participant')

plot5 <- ggplot(resp_rev_frame, aes(time, mean_target_hit))+
  geom_point(color = 'blue')+
  geom_smooth(color = 'blue', se= FALSE)+
  geom_point(aes(time,mean_target_false), color = "red")+
  geom_smooth(aes(time,mean_target_false), color = "red", se = FALSE)+
  geom_line(aes(time,mean(c(mean_target_hit, mean_target_false))), color = "gray")+
  xlab('time to movement in s')+
  ylab('distance target to goal (dva)')+
  facet_grid(participant~.)+
  blanktheme

plot5





```

Step 8: correct responses depending on distance attacker target at each tp:

```{r}
t = 0
dt = (1/120)*5

# plot go respones as a function of the presented target

for (tar in 1:10){
  go_response_attacker_target <- integrate_over(rev_frame_tar$V19,rev_frame_tar[,tar],rev_frame_tar$V20, 9)
  colnames(go_response_attacker_target) <- c('position', 'correct_responses', 'participant')
  
  title <- paste('target', round(t,digits=2), 's before movement', sep = " ")
  plot <- ggplot(go_response_attacker_target, aes(position,correct_responses, group = participant))+
    geom_point(aes(color = participant))+
    geom_smooth(aes(color = participant), se = FALSE)+
    xlab('Distance of the target to target enpoint (in dva)')+
    ylab('Proportion correct responses')+
    ylim(0.3,1)+
    ggtitle(title)+
    blanktheme
  
  plotname <- paste('plot',round(t, digits = 2),'.pdf',sep = "")
  pdf(plotname, width = 10/2.54, height = 8/2.54)
  print(plot)
  dev.off()
  
  t <- t+dt
  
}

```

Step 9: Plot the mean presented target location (relative to the attacker) at time t before movement onset.

```{r}
# only trials with go response
go_d_target <- d_attacker_norm

# in which column index is the first 
idx_first_target <- which(colnames(go_d_target)=='pos_vals_.1')
idx_move_on <- idx_first_target + go_d_target$posMovStart
idx_move_off <- idx_first_target + go_d_target$posMovEnd

presented_tars <- max(idx_move_on-idx_first_target)

rev_mat_tar <- matrix(ncol = presented_tars+2, nrow = length(go_d_target[,1]))
rev_frame_tar   <- as.data.frame(rev_mat_tar)


for (r in 1:length(go_d_target[,1])){
  start_target <- idx_move_on[r]
  target_seq   <- go_d_target[r,start_target:idx_first_target]
  rev_frame_tar[r,presented_tars+1] <- go_d_target$resp_correct[r]
  rev_frame_tar[r,presented_tars+2] <- go_d_target$participant[r]
  rev_frame_tar[r,1:length(target_seq)] <- target_seq
}


rev_hit_tar   <- rev_frame_tar[which(rev_frame_tar[,presented_tars+1]==1 & d_attacker_norm$goResp==1),]
rev_false_tar <- rev_frame_tar[which(rev_frame_tar[,presented_tars+1]==0 & d_attacker_norm$goResp==1),]


colN <- 8
dt <- -(1/120)*5

resp_rev_frame_tar <- matrix(ncol = 4, nrow = (colN*length(unique(go_d_target$participant))))
resp_rev_frame_tar <- as.data.frame(resp_rev_frame_tar)

idx <- 1

for (participant in unique(go_d_target$participant)){
  
  t <- 0
  
  for (frame in 1:colN){
    resp_rev_frame_tar[idx,1] <- t
    resp_rev_frame_tar[idx,2] <- mean(rev_hit_tar[which(rev_hit_tar[,presented_tars+2]==participant),frame], na.rm =  TRUE)
    resp_rev_frame_tar[idx,3] <- mean(rev_false_tar[which(rev_false_tar[,presented_tars+2]==participant),frame], na.rm =  TRUE)
    resp_rev_frame_tar[idx,4] <- participant
    t <- t+dt
    idx <- idx+1
  }
}  
  
colnames(resp_rev_frame_tar) <- c('time', 'mean_target_hit', 'mean_target_false', 'participant')

plot6 <- ggplot(resp_rev_frame_tar, aes(time, mean_target_hit))+
  geom_point(color = 'blue')+
  geom_point(aes(time,mean_target_false), color = "red")+
  geom_line(aes(time,mean(go_d_target[which(go_d_target$resp_correct == 1 & d_attacker_norm$goResp==1),70])), color = "gray")+
  geom_line(aes(time,mean(go_d_target[which(go_d_target$resp_correct == 0 & d_attacker_norm$goResp==1),70])), color = "gray")+
  xlab('time to movement in s')+
  ylab('distance target - attacker (dva)')+
  facet_grid(participant~.)+
  blanktheme

plot6

```
# Step 9: The same analysis, but relative to stimulus onset

```{r}

d_attacker_go <- d_attacker_norm[which(d_attacker_norm$goResp == 1),]
d_attacker_go_hit <- d_attacker_go[which(d_attacker_go$resp_correct == 1),]
d_attacker_go_false <- d_attacker_go[which(d_attacker_go$resp_correct == 0),]

t <- 0

colN <- 60
idx_first_target <- which(colnames(d_attacker_go)=='pos_vals_.1')

dt <- (1/120)*5

resp_frame_stimOn <- matrix(ncol = 3, nrow = colN)
resp_frame_stimOn <- as.data.frame(resp_frame_stimOn)

row = 1

for (frame in idx_first_target:(idx_first_target+colN)){
  resp_frame_stimOn[row,1] <- t
  resp_frame_stimOn[row,2] <- mean(d_attacker_go_hit[,frame], na.rm =  TRUE)
  resp_frame_stimOn[row,3] <- mean(d_attacker_go_false[,frame], na.rm =  TRUE)
  t <- t+dt
  row <- row+1
}
colnames(resp_frame_stimOn) <- c('time', 'mean_target_hit', 'mean_target_false')

plot7 <- ggplot(resp_frame_stimOn, aes(time, mean_target_hit))+
  geom_point(color = 'blue')+
  geom_point(aes(time,mean_target_false), color = "red")+
  geom_line(aes(time,mean(c(mean_target_hit, mean_target_false))), color = "gray")+
  blanktheme

plot7

```


Step 9 : Go responses as a function of the distance attacker_target

```{r}
```

Step 10: Random permutation

```{r}

```




Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.
